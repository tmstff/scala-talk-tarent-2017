| \b\*Case Classes, Pattern Matching & Immutability

1) Case Classes
2) Pattern Matching
3) Immutability
4) Feedback

---
| \b\* CASE CLASSES - Declaration & Initialization

| Declaration

```
case class Product (id: Int, category: String)

case class Order (id: Int, products: List[Product] = Nil)

case class User (name: String, orders: List[Order] = Nil)
```

--

| Initialization

```
val user = User(
  name = "Arnold",
  orders = List(
    Order( id = 1, products = List(
      Product( id = 1, category = "Tools" )))))
```

---
| \b\* CASE CLASSES - Methods

| Copy

```
val user2 = user.copy( name = "Arni" )
```

--

| toString()

```
println(s"user2='$user2'")
val userString = user.toString()
```

--

| equals() & hashCode()

```
println(user == user.copy())
println(user == user2)
println(s"h1: ${user.hashCode()}, h2: ${user2.hashCode()}")
```

---
| \b\* CASE CLASSES - equals() & hashCode()

| Properties can be excluded from equals() & hashCode():

```
case class Foo(a: Int)(b: Int)
println( Foo(0)(0) == Foo(0)(1) )
println( Seq(0, 1).map(Foo(0)(_).hashCode) )

```

---
| \b\* PATTERN MATCHING

```
def describe(x: String) = x match {
//.     matching expression
//.     |
//.     |         result, in case it's a match
//.     |         |
  case "Hallo" => "some hello"
  case "Hallo Welt" => "some hello world"
}
```
--

```
describe("Hallo Welt")
```
--

```
describe("Hallo")
```
--

```
describe("Foo")
```
---
| \*\b PATTERN MATCHING constant pattern + wildcard pattern


```
def describe2(x: Any) = x match {
  case 10 => "ten"
  case true | false => "boolean"
  case "hello" => "hi!"
  case Nil => "empty List"
  case _   => "something else"  //<--- wildcard pattern with default value
}
```
--

```
describe2(10)
```
--

```
describe2(true)
```
--

```
describe2(Unit)
```


---
| PATTERN MATCHING constructor pattern


```
case class Driver(name: String, age: Integer, sex: String)

case class Car(brand: String, driver: Driver)

val car1 = Car("Ferrari", Driver("Michael", 65, "male"))
val car2 = Car("Ford", Driver("Michael", 65, "male"))
val car3 = Car("BMW", Driver("Michaela", 23, "female"))
val car4 = Car("VW", Driver("Tim", 17, "male"))

def insurance(car: Car) = car match {
  case Car(_, Driver(name, age, _)) if age < 18 => throw new RuntimeException(s"$name is too young to drive!")
  case Car("Ferrari", Driver(_, age, "male"))   => 1500 * (100 - age) / 100
  case Car(_, Driver(_, age, "male"))           => 1200 * (100 - age) / 100
  case car                                      => 1000 * (100 - car.driver.age) / 100
}

```

---
| \b\* PATTERN MATCHING lists


```
def concat(l: List[String]): String = l match {
  case Nil => ""
  case elem :: tail => elem + concat(tail)
}

concat(List("A", "B", "C"))
```


--

Möchten wir nun auf einen BMW matchen und zusätzlich im Nachhinein
diesen Wagen auch mit `startEngine` starten, so können wir das ganze
Objekt mit einer Variable belegen: `varName @ [Pattern]`:

```
Car("blue", "BMW", 30000) match {
  case c @ Car(_, "BMW", _) => println(c.startEngine())
}
```

---
| \b\* Pattern guards & Tuple Patterns

Möchte man ein pattern noch etwas verfeinern, so kann man, kombiniert
mit dem variable binding, diesem ein pattern guard beigeben.
Dabei habdelt es sich einfach um ein if, welches direkt nach dem Pattern,
also noch vor dem `=>` geschrieben wird:

```
Car("blue", "BMW", 30000) match {
  case Car(_, "Audi", km) if km < 20000 => println("Adult male")
  case Car(_, "BMW", _) => println("childish male")
}
```
--

Tuples können ähnlich wie case classes über ein Konstruktor pattern gematched werden:

```
(1, 2, 3) match {
  case (_, _, 2) => println("_, _, 2")
  case (_, 2, 4) => println("_, 2, 4")
  case (1, _, _) => println("1, _, _")
}
```
---
| \b\* Typed patterns

Typed patterns ermöglichen es, anhand des Datentyps zu filtern.
`typeMatcher` arbeitet mit einem Value vom Typ `Any`. Im Matchingblock überprüfen wir nun den
eigentlichen Typ des Values. Die Syntax ist hier wie bei einer Variablendeklaration. Also
`name`: `type`. Alternativ kann als `name` auch das Wildcardzeichen benutzt werden, wenn uns nur der
Typ interessiert:

```
def typeMatcher(x: Any) = x match {
  case theString: String => println("A String with value: " + theString)
  case theInt: Int => println("An Integer with value: " + theInt)
  case _: Boolean => println("A Boolean value")
  case _ => println("Something other")
}
typeMatcher("Hallo")
typeMatcher(43)
typeMatcher(true)
typeMatcher(34.5)
```


---
| \b\* Typed patterns & Type erasures

WARNUNG: Type erasures!!! Oder: Ein kleiner Exkurs in die tiefen Tiefen der JVM.
Auf der JVM sind Generic Informationen lediglich zur Compilezeit bekannt.
Zur Laufzeit sind diese Informationen nicht mehr vorhanden. Eine List[Int]
ist dort äquivalent zu List[String].
Beim Pattern Matching ist man schnell versucht ein Typpattern mit Generics
zu versuchen. Wie im folgenden Beispiel eine Map, deren Values Integers sind,
deren Keytyp uns aber egal ist:

```
def isIntCollection(x: Any) = x match {
  case m: Map[_, Int] => true
  case a: Array[Int] => true
  case _ => false
}
```

--

Durch das type erasure wird nun folgender Ausdruck zu true ausgewertet,
obwohl wir definitiv eine Map[String, String] als Parameter geben.
Das Problem des type erasures tritt auch in Java auf. Siehe:
   http://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html

```
isIntCollection(Map("x" -> "y"))
```

--

Aaaaaaber. Was passiert, wenn wir ein `Array("hallo")`, also ein Array[String]
übergeben? Seltsamerweise erhalten wir hier ein `false` von der Methode.

Arrays stammen noch aus einer Zeit der JVM als es noch keine Generics gab. Sie sind
daher ein Spezielfall, da sie die einzige Collectionstruktur sind, die direkt von der JVM
unterstützt werden und nicht erst programmatisch erzeugt werden müssen.
Arrays sind auch die einzige Collection, die zur Laufzeit ihren Typ
behält. Ein Java `int[]` ist eben ein eigener Typ und äquivalent zu dem Scala Array[Int].
s. auch: http://code.stephenmorley.org/articles/java-generics-type-erasure/

```
isIntCollection(Array("hallo"))
```


---
| \b\* Patterns everywhere

Das Konstruktorpattern kann auch direkt bei einer Variablendekleration benutzt werden.
Hier extrahieren wir die Farbe des Autos mit einem Konstruktorpattern
und speichern den Wert in der Variable `color`, welche wir im Anschluss direkt
benutzen können.
```
val car = Car("red", "Jaguar", 20000)
val Car(colour, _, _) = car
println(colour)
```

Das Autobeispiel wäre vermutlich mit einem `car.colour` schneller und nachhaltiger
gewesen. Tatsächlich ist diese Variablendeklaration auch eher für ein einfach und
übersicherlicheres extrahieren von Tupledaten geeignet:
Das geht meist einfacher von der Hand als ein
  val t = getTuple()
  println(t._1)

```
def getTuple(): (String, Int) = ("hallo", 123)
val (string, number) = getTuple()

println(string)
println(number)
```


---
| \b\* Abstract classes

a simple abstract class with an abstract method.
```
abstract class AbstractCar {
  ///We can define abstract methods definitions like in java:
  def startEngine: String

  ///But we can also define abstract FIELD definitions:
  val color: String

  ///And of course predefine some fields:
  val tireCount: Int = 4
}
```

--

Now we can extend a concrete sub class. This class must implement the startEngine method and
color field with a value. Otherwise the code won't compile. :

```
class Bmw extends AbstractCar {

  def startEngine: String = "WWRRRRÖÖÖÖÖAAAAAAAAMMMMMMMMMMMM!!!"

  val color = "blue"  //This is a field "implementation"
}
```

---
| \b\* Abstract classes overriding

We extends an abstract fueled car with a new constructor argument
```
abstract class FueledCar(fillingLevel: Int) extends AbstractCar {
  //We set the color implementation as final.
  //So no inherited class can override it. Like in Java.
  final val color: String = "blue"
}
```

--

We can override the tireCount method. But in scala me MUST add the prefix `override`.
We also must give the inherited class it's constructor argument.
Btw: This PiaggioApe is final. It can not be inherited!
```
final class PiaggioApe extends FueledCar(40) {
  //Implements the startEngine METHOD as a VALUE!
  //This is possible. But you can not implement a val
  //definition with a method, cause the scala compiler
  //checks if the implementation is a strict immutable value
  //So: def -> var
  //.   def -> val
  //.    var -> val
  //.    var -> def
  val startEngine: String = "Töf töf töf töf töf töf töf..."

  //Here we override the pre defined value.
  override val tireCount = 3

  //We can not override the color cause it's final.
  //override def color = "green"
}
```

---
| \b\* Traits 1

Trais are like interfaces, which can also have fields and a default implementation.
The following is a simple trait with two 'abstract' fields which must be 'implemented' with a value.
Also a default implementation of a method `sayHello`
```
trait Person {
  val name: String
  val gender: String
  def sayHello() = println(s"Hello! I'm $name!")
}
```

--

We can "mix in" the trait with 'extends' (for the first) or 'with' (for the following) traits.
```
class Student(val name: String, val gender: String) extends Person

val student = new Student("max", "male")
student.sayHello()
```

---
| \b\* Traits 2

We can define another trait which we want to mix in into our subclass.
This trait represents a user of a cafeteria. It has a budget, can buy food and
deposit money onto the budget.
This trait has only default implemented methods. So is probably could also stand alone
as a class. But we want to mix this one into other classes.
```
trait CafeteriaUser {
  private var budget: Int = 0

  def actualBudget = budget

  def buyFood(costs: Int) = if(budget - costs < 0) {
    throw new RuntimeException("You can not buy food! Not enough money!")
  } else {
    budget = budget - costs
  }

  def deposit(value: Int) = budget = budget + value
}
```

--

So we define a class `Employee` which is a `Person` and also a `CafeteriaUser`:
To do this, we extend the Person class and mix in the `CafertiaUser` with the keyword `with`.
```
class Employee(val name: String, val gender: String) extends Person with CafeteriaUser {
  val beginOfEmployment = new java.util.Date
}
```

--

```
val employee = new Employee("Susan", "female")
employee.sayHello()
employee.deposit(100)
employee.actualBudget

var user: CafeteriaUser = employee

new Student(name="Arnold", gender="male") with CafeteriaUser
```

---
| \b\* Übungen (für's nächste mal)

https://github.com/tmstff/scala-dojo-yann - section4

---
| \b\* Feedback

Feedback: für zukünftige Workshops: andere Reihenfolge besser? Zuerst der "cool Stuff",
und dann erst die Details?
